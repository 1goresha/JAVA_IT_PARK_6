# Spring

* Классы приложения не должны знать о конкретных реализациях друг друга.

* Каждый класс должен работать только с поведением на уровне интерфейса. Ведь гарантируется, что каждый класс, имплементирующий какой-либо интерфейс, обязуется реализовать все его методы.

* Если приложение очень большое, возникает задача частой смены реализаций каких-либо классов. Например:

```
class A {
	private B b;

	public A() {
		this.b = new B();
	}

	public void someMethodInA() {
		b.someMethonInB();
	}
}

class B {
	public void someMethodInB() {
		...
	}
}
```

А что, если нам нужна другая реализация метода someMethodInB? Тогда необхдимо перписывать код.

* Решение - использовать агрегирование со слабой связью:

```
class A {
	private C c;

	public A(C c) {
		this.c = c;
	}

	public void someMethodInA() {
		c.someMethod();
	}
}

interface C {
	void someMethod();
}

class B implements C {
	void someMethod() {
		...
	}
}

class D implements C {
	void someMethod() {
		...
	}
}
```

* А если возникает необходимость поменять конфигурацию приложения? Например, чтобы теперь класс A не зависил от B через C, а зависил от D через С. Как это сделать без перекопиляции программы?

* Решение - единственно верное архитектурное решение - использование паттерном DI/IoC. Данные паттерны предполагают, что соединением (связываем) всех компонентов системы между собой должен заниматься отдельный контейнер.

* Bean - в терминах фреймворка Spring это компонент вашей системы. Обычно какой-либо объект. Характеризуется своим id, а также классом, от которого данный бин был создан.

## Таким образом

* Приложение состоит из бинов (компонентов).

* Нет необходимости создавать объекты классом прямо в коде, а также связывать их между собой - теперь все это можно сделать в contex.xml. 

* В Java-коде достаточно просто получить необходимый бин (компонент), все его связи будут проставлены согласно файлу context.xml.

* Код становится чище - потому что теперь вы не засоряете код связываниями и созданиями объектов, вы прописываете только необходимую логику.

## Подробнее о компнентах Spring

* ApplicationContext - интерфейс, описывающий IoC-контейнер. То есть контейнер, который хранит все компоненты системы (бины). Каждый бин можно запросить по его названию и типу класса, которому соответствует.

* ClassPathXmlApplicationContext - класс-контейнер, считывающий бины из xml-файла.

* scope бина - singleton(по умолчанию), prototype - каждый запрос - новый объект.

## Java Config

* Возможность создать методы, помеченные аннотацией @Bean. Каждый такой метод создает бин, по тем правилам, которые были указаны в методе.

## Почти FullAnnotationConfig

* Используем аннотацию @Component. Данной аннотацией помечаем ваши классы, экземпляры которых могут быть бинами.

* @Autowired - автосвязывание. Помечем данной аннотацией (как правило) - поля. Spring видя данную аннотацию, смотрит какой тип имеет данное поле, далее ищет бины подходящие по типу и  связывает их в этом поле.